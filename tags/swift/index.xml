<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>swift on My dear diary</title><link>https://yaroslavyaroslav.github.io/tags/swift/</link><description>My dear diary (swift)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 03 Oct 2022 17:01:43 +0700</lastBuildDate><atom:link href="https://yaroslavyaroslav.github.io/tags/swift/index.xml" rel="self" type="application/rss+xml"/><item><title>Dynamic generic types</title><link>https://yaroslavyaroslav.github.io/posts/generic-protocol-workaround/</link><pubDate>Mon, 03 Oct 2022 17:01:43 +0700</pubDate><guid>https://yaroslavyaroslav.github.io/posts/generic-protocol-workaround/</guid><description>&lt;h2 id="abstract" >Abstract
&lt;span>
&lt;a href="#abstract">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Prior to the Swift 5.7 release, there was a lack of support for using protocols with associatedtype as a type of passed argument or as a returning type. Prior to this release, the options to solve such tasks as with &lt;a href="https://github.com/apple/swift-evolution/blob/main/proposals/0309-unlock-existential-types-for-all-protocols.md" title="">SE-0309&lt;/a> and &lt;a href="https://github.com/apple/swift-evolution/blob/main/proposals/0346-light-weight-same-type-syntax.md" title="">SE-0346&lt;/a> were not available.&lt;/p>
&lt;p>However, these tasks still exist. In the past, Apple&amp;rsquo;s solution was to do a lot of boilerplate code, such as writing many overloaded methods to cover all cases.&lt;/p>
&lt;p>Let&amp;rsquo;s review another solution that solves some, but not all of these tasks.&lt;/p>
&lt;h2 id="problem-overview" >Problem overview
&lt;span>
&lt;a href="#problem-overview">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>The problem comes from the restrictions of protocols and generics. To illustrate this, let&amp;rsquo;s consider the task of implementing a method that can decode any Decodable object. This is a useful task when receiving a server response wrapped in object that couldn&amp;rsquo;t be mapped to a JSON key, and we want to cover this response with a single type.&lt;/p>
&lt;p>As an example, we have two possible received JSON objects:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;result&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;firstKey&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;secondKey&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;second&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;client&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;iOS&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;result&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;thidrKey&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;okok&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;fourthKey&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;fifthKey&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1231&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;client&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;iOS&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The preferred solution would be to implement one generic method and three structures, one for each given result case, and one for the response itself.&lt;/p>
&lt;p>We can define structs for each type of the result object:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// `result` object for first kind of server response&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ResultFirstKind&lt;/span>: Decodable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> firstKey: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> secondKey: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// `result` object for second kind of server response&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ResultSecondKind&lt;/span>: Decodable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> thidrKey: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> fourthKey: Bool
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> fifthKey: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>and a wrapper struct for the response:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Response&lt;/span>: Decodable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> id: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> result: Decodable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> client: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>However, when we try to implement a method that uses this struct, such as:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">send&lt;/span>(uRLRequest: URLRequest, with session: URLSession) async &lt;span style="color:#66d9ef">throws&lt;/span> -&amp;gt; Response {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> (data, response) = &lt;span style="color:#66d9ef">try&lt;/span> await session.data(&lt;span style="color:#66d9ef">for&lt;/span>: uRLRequest)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span> == response.statusCode &lt;span style="color:#66d9ef">else&lt;/span> { fatalError() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> JSONDecoder().decode(APIResponse.&lt;span style="color:#66d9ef">self&lt;/span>, from: data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>we face a problem: the compiler cannot infer the type of the concrete result field in the implementation for an exact call with ``. Since it could be any decodable type, there is not even a hint as to which it will be in the exact call.&lt;/p>
&lt;h2 id="problem-summary" >Problem summary
&lt;span>
&lt;a href="#problem-summary">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;ol>
&lt;li>In Swift, the compiler cannot infer a non-generic type from a protocol set as a method parameter type or its returning type. We have to explicitly specify the concrete type that is covered under the generic one in the method calling code and in the method declaration.&lt;/li>
&lt;li>Prior to Swift version 5.7, protocols with associatedtype values could not be used as a constraint for a generic method type parameter or return type. Therefore, we need a way to pass the required restrictions into the call chain to limit the possible types to those that we are expecting.&lt;/li>
&lt;/ol>
&lt;h2 id="the-solution" >The solution
&lt;span>
&lt;a href="#the-solution">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>The solution is to use a combination of generics and protocols to provide the necessary type information to the compiler.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protocol&lt;/span> &lt;span style="color:#a6e22e">Resultable&lt;/span>: Decodable { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ResultFirstKind&lt;/span>: Resultable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> firstKey: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> secondKey: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ResultSecondKind&lt;/span>: Resultable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> thidrKey: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> fourthKey: Bool
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> fifthKey: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">APIResponse&lt;/span>&amp;lt;Result&amp;gt;: Decodable &lt;span style="color:#66d9ef">where&lt;/span> Result: Resultable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> id: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> result: Result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> client: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">send&lt;/span>&amp;lt;Result&amp;gt;(uRLRequest: URLRequest, with session: URLSession) async &lt;span style="color:#66d9ef">throws&lt;/span> -&amp;gt; APIResponse&amp;lt;Result&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> (data, response) = &lt;span style="color:#66d9ef">try&lt;/span> await session.data(&lt;span style="color:#66d9ef">for&lt;/span>: uRLRequest)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span> == response.statusCode &lt;span style="color:#66d9ef">else&lt;/span> { fatalError() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">try&lt;/span> JSONDecoder().decode(APIResponse&amp;lt;Result&amp;gt;.&lt;span style="color:#66d9ef">self&lt;/span>, from: data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> result: APIResponse&amp;lt;ResultSecondKind&amp;gt; = &lt;span style="color:#66d9ef">try&lt;/span> await APIRequest.send(uRLRequest: URLRequest(url: URL(&lt;span style="color:#e6db74">&amp;#34;http://google.com&amp;#34;&lt;/span>)&lt;span style="color:#f92672">!&lt;/span>), with: URLSession.shared)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>The &lt;code>Resultable&lt;/code> protocol is declared, this protocol restricts the variation of types that conform to &lt;code>Decodable&lt;/code> to types that we are expecting to be in the server response.&lt;/li>
&lt;li>The possible &lt;code>Result&lt;/code> types that could be returned by the server are implemented. Both of them conform to both the &lt;code>Resultable&lt;/code> and &lt;code>Decodable&lt;/code> protocols.&lt;/li>
&lt;li>The &lt;code>APIResponse&amp;lt;Result&amp;gt;&lt;/code> structure is declared which declares a generic type &lt;code>Result&lt;/code> with a constraint to types that conform to the &lt;code>Resultable&lt;/code> protocol.&lt;/li>
&lt;li>A generic method &lt;code>send&amp;lt;Result&amp;gt;(...) ... -&amp;gt; APIResponse&amp;lt;Result&amp;gt;&lt;/code> is implemented that returns a concrete &lt;code>APIResponse&lt;/code> type but with a yet generic property &lt;code>Result&lt;/code>.&lt;/li>
&lt;li>In the call of the send method, explicitly declaring the &lt;code>Result&lt;/code> type in the function call is required. This notation let result: &lt;code>APIResponse&amp;lt;ResultSecondKind&amp;gt; = ... send()&lt;/code> tells the compiler what concrete type we are expecting for a given call. And by this call, the compiler can infer the type that will be used.&lt;/li>
&lt;/ol>
&lt;p>In this way, we can use the &lt;code>APIResponse&lt;/code> struct to wrap any type of &lt;code>Decodable&lt;/code> object and the send method to handle it correctly.&lt;/p>
&lt;p>This solution also gives you the possibility to extend the generic method with one line of code by conforming a given type to the Resultable protocol.&lt;/p>
&lt;p>This works on the client side as well. If you&amp;rsquo;re using a network library, this is a great feature because your users can pass in their own Result types instead of the ones provided by you, which gives a broad flexibility without increasing complexity.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ClientImplementationResultSecond&lt;/span>: Responsable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> thidrKey: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> fourthKey: Bool
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> fifthKey: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// all good&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> result: APIResponse&amp;lt;ClientImplementationResultSecond&amp;gt; = &lt;span style="color:#66d9ef">try&lt;/span> await APIRequest.send(uRLRequest: URLRequest(url: URL(&lt;span style="color:#e6db74">&amp;#34;http://google.com&amp;#34;&lt;/span>)&lt;span style="color:#f92672">!&lt;/span>), with: URLSession.shared)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Limitations&lt;/p>
&lt;ul>
&lt;li>This method does not work if you&amp;rsquo;re using shorthand call (it will not compile).&lt;/li>
&lt;li>This method couldn&amp;rsquo;t be turned upside down to use it for encode generic type (e.g. create generic request). At least we haven&amp;rsquo;t found it yet, so if you do, please let us know.&lt;/li>
&lt;/ul></description></item></channel></rss>